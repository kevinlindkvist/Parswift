import Foundation

public struct ParseError {
  let position: SourcePosition
  let messages: [ErrorMessage]

  public init(position: SourcePosition, messages: [ErrorMessage]) {
    self.position = position
    self.messages = messages
  }
}

extension ParseError: CustomStringConvertible {
  public var description: String {
    return "Error at \(position): \(messages)"
  }
}

public enum ErrorMessage {
  /// A message that is automatically generated by `satisfy` where the argument is the unexpected input.
  case systemUnexpected(String)
  /// A message generated by `unexpected` combinator where the argument describes the unexpected item.
  case unexpected(String)
  /// A message generated by `<?>` where the argument describes the expected item.
  case expected(String)
  /// A raw message generated by the `fail` combinator.
  case message(String)
}

extension ErrorMessage: CustomStringConvertible {
  public var description: String {
    switch self {
    case let .systemUnexpected(value): return value
    case let .unexpected(value): return value
    case let .expected(value): return value
    case let .message(value): return value
    }
  }
}

func merge(firstError: ParseError, secondError: ParseError) -> ParseError {
  switch (firstError.messages.count, secondError.messages.count) {
  case let (a, 0) where a > 0: return firstError
  case let (a, b) where a > b: return firstError
  case let (0, b) where b > 0: return secondError
  case let (a, b) where b > a: return secondError
  default: return ParseError(position: firstError.position, messages: firstError.messages + secondError.messages)
  }
}

func unknownError<Input: Collection, UserState> (state: State<Input, UserState>) -> ParseError {
  return ParseError(position: state.position, messages: [])
}
